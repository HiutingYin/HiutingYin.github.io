---
title: redis的排行榜处理
date: 2021-03-24 18:27:10 +0800
categories: 
- 日常问题合集
tags: 
- Reids
excerpt：redis的ZINTERSTORE方法实战
---

#### 前言

------------
**该方法实现逻辑感觉较为复杂！！！不推荐！！！只是总结redis 的 zInter 方法。**

在活动开发过程中，经常会有关于排行榜的需求。
实现一个排行榜，我们通常想到的就是mysql的order by，简单粗暴就能实现相关功能，但是用数据库的话，隐患也是不小。
比如当用户数达到一定级别，即使有索引、加缓存，花费的时间还是不容小觑，并且排行榜的实时性也是很重要的。
这时候可以考虑一下Redis的有序集合。

Redis的有序集合是一个非常高效的数据结构。

其中ZADD将一个或者多个member元素及其score值加入有序集合key当中。如果某个member已经是有序集合的成员，那么更新这个member的score值，并通过重新插入这个member元素，来保证该 member 在正确的位置上，保证按照一定顺序连续排列。

通过ZRANK可以快速得到用户的排名，通过ZRANGE可以快速得到TOP N的用户列表，它们的复杂度都是O(log(N))，用来替代数据库查询可以大大提升性能，可以满足一般的排行榜需求。


#### 示例场景

------------
如果有排行榜的话，肯定有对应的排序规则，比如用户游戏积分降序排序，当积分相同情况下，按照达到积分的时间升序等。

在一个H5活动开发过程中，有个每日城池探索功能，每日玩家可选择一个城池进行争霸，城池结算时间为每日0点。选择城池后可在争霸时间内更换选择。
每个城池有一个城池探索排行榜，根据玩家的队伍积分进行排序，当积分相同时，按照探索时间升序，越早探索排名越前。


一般处理方式如下：
1.记录用户占领城池
2.判断是否有更新城池
3.更新用户积分（用户积分=游戏得分+处理过后的时间）
```
    /**
     * 累加城池信息
     * @param $uid
     * @param $score
     * @param $curCity
     */
    public function incScore($uid, $score, $curCity)
    {
        $redis = redis::getInstance();
        $userKey = sprintf('zf:userCity:%d', date('Ymd'));
        $myCity = $redis->hGet($userKey, $uid);

        $score += (1 - time() / 10000000000);//按照时间升序，越早达到排越前面，对应的时间影响力处理成小数

        //城池信息不一致，说明用户要更换城池
        if ($myCity && $myCity != $curCity) {
            //移除旧城池信息
            $cityKey = sprintf('zf:city:%s:%d', $myCity, date('Ymd'));
            $redis->zRem($cityKey, $uid);
        }
        //记录积分
        $myCityKey = sprintf('zf:city:%s:%d', $curCity, date('Ymd'));
        $redis->zAdd($myCityKey, $score, $uid);
    }
```

但是其实可以通过 ZINTERSTORE 来处理
ZINTERSTORE 计算给定的一个或多个有序集的交集。
这样可以保证 用户得分数据和占领时间，这两个数据的独立性，更方便我们做数据处理。
```
    /**
         * Creates an intersection of sorted sets given in second argument.
         * The result of the union will be stored in the sorted set defined by the first argument.
         * The third optional argument defines weights to apply to the sorted sets in input.
         * In this case, the weights will be multiplied by the score of each element in the sorted set
         * before applying the aggregation. The forth argument defines the AGGREGATE option which
         * specify how the results of the union are aggregated.
         *
         * @param   string  $Output
         * @param   array   $ZSetKeys
         * @param   array   $Weights
         * @param   string  $aggregateFunction Either "SUM", "MIN", or "MAX":
         * defines the behaviour to use on duplicate entries during the zInter.
         * @return  int     The number of values in the new sorted set.
         * @link    https://redis.io/commands/zinterstore
         * @example
         * <pre>
         * $redis->delete('k1');
         * $redis->delete('k2');
         * $redis->delete('k3');
         *
         * $redis->delete('ko1');
         * $redis->delete('ko2');
         * $redis->delete('ko3');
         * $redis->delete('ko4');
         *
         * $redis->zAdd('k1', 0, 'val0');
         * $redis->zAdd('k1', 1, 'val1');
         * $redis->zAdd('k1', 3, 'val3');
         *
         * $redis->zAdd('k2', 2, 'val1');
         * $redis->zAdd('k2', 3, 'val3');
         *
         * $redis->zInter('ko1', array('k1', 'k2'));               // 2, 'ko1' => array('val1', 'val3')
         * $redis->zInter('ko2', array('k1', 'k2'), array(1, 1));  // 2, 'ko2' => array('val1', 'val3')
         *
         * // Weighted zInter
         * $redis->zInter('ko3', array('k1', 'k2'), array(1, 5), 'min'); // 2, 'ko3' => array('val1', 'val3')
         * $redis->zInter('ko4', array('k1', 'k2'), array(1, 5), 'max'); // 2, 'ko4' => array('val3', 'val1')
         * </pre>
         */
        public function zInter($Output, $ZSetKeys, array $Weights = null, $aggregateFunction = 'SUM') {}
```


#### 解决思路

------------
我们可以拆分成2个集合。
集合一：记录每日得分，对应的member值是玩家的uid，score为对应的积分
集合二：记录每日城池占领的玩家信息，记录占领时间

查询排行榜时，实际是取 集合一和集合二的交集。

<span style="padding: 2px; background-color: #c1cbd7;">
这么做，主要是考虑到这次的城池占领可能会出现以下几种情况：  <br/>
1.用户首次占领城池并累加积分  <br/>
2.用户更换城池，不修改积分  <br/>
3.用户更换城池，并累加积分  <br/>
如果将用户积分和占领时间，记录在同一个集合中，代码处理会比较复杂紊乱。  <br/>
拆分成多个集合，我们只要处理需要改变的集合数据即可。  <br/>
比如用户更换城池不修改积分时，我们只需要修改用户的占领的城池信息，不需要修改到得分。数据相对独立。  
</span>
```
    /**
     * 累加城池信息
     * @param $uid 当前玩家uid
     * @param $score 当前玩家要累加的积分
     * @param $curCity 选择的城池
     */
    public function incScore($uid, $score, $curCity)
    {
        $redis = redis::getInstance();

        //获取玩家今日占领的城池
        $userKey = sprintf('zf:userCity:%d', date('Ymd'));
        $myCity = $redis->hGet($userKey, $uid);

        //城池信息不一致，说明用户要更换城池
        if ($myCity != $curCity) {
            //更新我今日占领的城池
            $redis->hSet($userKey, $uid, $curCity);
            //移除旧城池占领时间
            if ($myCity) {
                $cityKey = sprintf('zf:city:%s:%d', $myCity, date('Ymd'));
                $redis->zRem($cityKey, $uid);
            }
            $curCityKey = sprintf('zf:city:%s:%d', $curCity, date('Ymd'));
            $redis->zAdd($curCityKey, (1 - time() / 10000000000), $uid);
        }
        if($score){
            //累加玩家今日得分
            $scoreKey = sprintf('zf:cityScore:%d', date('Ymd'));
            $redis->zIncryBy($scoreKey, $score, $uid);
        }
    }

    /**
     * 获取对应城池的今日排行榜
     * @param $city
     * @return array
     */
    public function cityRank($city)
    {
        $redis = redis::getInstance();
        
        //对应城池的占领用户信息（存储的是uid+争霸时间）
        $cityKey = sprintf('zf:city:%s:%d', $city, date('Ymd'));
        //玩家的积分排行榜（存储的是uid+对应积分）
        $scoreKey = sprintf('zf:cityScore:%d', date('Ymd'));

        $rankKey = sprintf('zf:cityRank:%s:%d', $city, date('Ymd'));
        //获取对应城池用户 及 用户今日城池积分的交集
        $redis->zInter($rankKey, [$cityKey, $scoreKey], [1, 1]);
        $rank = $redis->zRevRange($rankKey, 0, 100, true);
        return $rank;
    }  
```


#### 最后

------------
不管是<font color='red'> MySQL </font>还是<font color='red'> REDIS </font>，还是要具体情况具体分析，实现功能是基础，提高性能是目标。
